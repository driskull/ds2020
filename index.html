<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <title>Swipe Widget with Scroll - 4.14</title>

    <link rel="stylesheet" href="/git/arcgis-js-api-4/esri/css/main.css" />
    <script src="/git/arcgis-js-api-4/test-apps/dojo-config.js"></script>
    <script src="/git/arcgis-js-api-4/dojo/dojo.js"></script>
    <!--<script src="//jsdev.arcgis.com/4.0beta1/"></script>-->

    <!-- <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.14/esri/themes/light/main.css"
    />
    <script src="https://js.arcgis.com/4.14/"></script> -->

    <style type="text/css" media="screen">
      html,
      body,
      #viewDiv {
        font-family: "Avenir Next W00", "Helvetica Neue", Helvetica, Arial,
          sans-serif;
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
      }

      #viewDiv {
        position: absolute;
        z-index: 1;
      }

      #gridDiv {
        position: absolute;
        z-index: 2;
        width: 100%;
        bottom: 0;
        /* height: 30%; */
      }

      .feature-table-button {
        border: none;
      }

      .scroller {
        position: absolute;
        overflow-y: scroll;
        width: 350px;
        background-color: rgba(255, 255, 255, 0.7);
        height: 100%;
        right: 0;
        padding: 0;
        margin: 0;
        z-index: 2;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      }

      .scroller > .content {
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        align-content: stretch;
        justify-content: space-evenly;
      }

      .scroller > .content > .slide {
        flex: 1;

        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
      }

      .legend {
        background-color: transparent;
        width: 100%;
        visibility: hidden;
        /* set visibility after map initialization */
      }

      #sliderDiv {
        box-sizing: border-box;
        z-index: 2;
        position: absolute;
        padding: 40px 60px;
        width: 60%;
        margin: 0 20%;
        bottom: 36px;
        background-color: rgba(255, 255, 255, 0.7);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      }

      .esri-slider {
        background: transparent;
      }

      .slider-heading {
        text-align: center;
        margin: 0 0 30px 0;
        padding: 0;
      }
    </style>

    <script>
      require([
        "esri/WebMap",
        "esri/views/MapView",
        "esri/widgets/Swipe",
        "esri/widgets/Legend",
        "esri/widgets/Slider",
        "esri/widgets/FeatureTable/support/FeatureStore",
        "esri/widgets/FeatureTable/Grid/Column",
        "esri/widgets/FeatureTable/Grid/Grid",
        "esri/widgets/FeatureTable/Grid/GridViewModel"
      ], function(
        WebMap,
        MapView,
        Swipe,
        Legend,
        Slider,
        FeatureStore,
        Column,
        Grid,
        GridViewModel
      ) {
        let view, swipes;

        const scroller = document.querySelector(".scroller");
        const content = scroller.querySelector(".content");

        // initialize the map
        const map = new WebMap({
          portalItem: {
            id: "876936467da74ac29dae381c45a25dd0"
          }
        });

        map
          .load()
          .then(function() {
            // create the view
            view = new MapView({
              container: "viewDiv",
              map: map,
              // zoom: 5, // todo: find this later
              // center: [-102, 23],
              padding: {
                right: 350
              }
            });

            view.on("mouse-wheel", function(event) {
              scroller.scrollTop = scroller.scrollTop + event.deltaY;
              event.stopPropagation();
            });

            const featureTableToggle = document.createElement("button");
            featureTableToggle.title = "Feature table";
            featureTableToggle.addEventListener("click", function() {
              gridDiv.toggleAttribute("hidden");
            });
            featureTableToggle.className =
              "esri-widget--button esri-icon-table feature-table-button";
            view.ui.add(featureTableToggle, "top-left");

            const sliderDiv = document.createElement("div");
            const sliderHeading = document.createElement("h2");
            sliderHeading.className = "slider-heading";
            sliderHeading.textContent = "Season";
            sliderDiv.appendChild(sliderHeading);
            sliderDiv.id = "sliderDiv";
            const seasons = ["Winter", "Spring", "Summer", "Fall"];
            const slider = new Slider({
              container: document.createElement("div"),
              min: 0,
              max: 3,
              values: [0],
              steps: 1,
              visibleElements: {
                labels: true,
                rangeLabels: false
              }
            });
            slider.tickConfigs = [
              {
                mode: "count",
                values: 4
              }
            ];
            slider.labelFormatFunction = function(value, type) {
              return seasons[value];
            };

            sliderDiv.appendChild(slider.container);
            view.ui.add(sliderDiv, "manual");

            // get the layers from the webmap
            const layers = map.layers;

            // create a swipe widget for each layer
            swipes = layers.map(function(layer) {
              return new Swipe({
                view: view,
                disabled: true,
                position: 100,
                direction: "vertical",
                trailingLayers: [layer],
                visibleElements: {
                  handle: false,
                  divider: true
                }
              });
            });

            // Generate 'columns' from layer fields
            // Requires using a custom renderer to work with our custom store
            function getColumns() {
              if (!layer.fields) {
                return [];
              }

              const renderFunction = ({ root, column, rowData }) => {
                if (
                  !column ||
                  !column.path ||
                  !rowData ||
                  !rowData.item ||
                  !rowData.item.feature
                ) {
                  return "";
                }

                root.innerHTML =
                  rowData.item.feature.attributes[column.path] || "";
              };

              const ignoredFields = [
                "wfo",
                "etn",
                "shape__area",
                "shape__length",
                "issuedate",
                "status"
              ];

              return layer.fields
                .filter(
                  field =>
                    ignoredFields.indexOf(field.name.toLowerCase()) === -1
                )
                .map(field => {
                  return new Column({
                    path: field.name,
                    header: field.alias || field.name,
                    // sortable: true,
                    renderFunction
                    // headerRenderFunction: ({ root }) => {
                    //   root.innerHTML = "test123";
                    // }
                  });
                });
            }

            // Converts 'sortOrder' from Vaadin-Grid to correct format for 'orderByFields' for layer query
            function getOrderByFieldsFromSortOrder(orders) {
              if (!orders || !orders.length) {
                return [];
              }

              return orders
                .filter(
                  (order, pos, arr) =>
                    arr.map(ord => ord.path).indexOf(order.path) === pos
                )
                .map(
                  ({ direction, path }) => path + " " + direction.toUpperCase()
                );
            }

            // Converts 'filters' from Vaadin-Grid to correct format for 'where' clause for layer query
            function getWhereClauseFromFilter(filters) {
              return filters
                .filter(
                  ({ value }) =>
                    value !== null && value !== undefined && value !== ""
                )
                .map(
                  (filter, i) =>
                    (i > 0 ? " AND " : "") +
                    `${filter.path} LIKE '%${filter.value}%'`
                )
                .join(""); // TODO - breaks querying in some workflows
            }

            const layer = layers.getItemAt(0);
            const store = new FeatureStore({
              layer
            });
            // Use layer fields to generate columns
            layer.when(() => grid.set("columns", getColumns()));

            const gridDiv = document.createElement("div");
            gridDiv.id = "gridDiv";
            gridDiv.hidden = true;
            view.ui.add(gridDiv, "manual");

            const grid = new Grid({
              viewModel: new GridViewModel({
                // Modify 'dataProvider' to work with our custom store
                dataProvider: async function(params, callback) {
                  const { page, pageSize, sortOrders, filters } = params;
                  const orderByFields = getOrderByFieldsFromSortOrder(
                    sortOrders
                  );
                  const where = getWhereClauseFromFilter(filters) || "1=1";
                  // const where = "OBJECTID = 2";

                  await store.set({
                    orderByFields,
                    where
                  });

                  if (store.state !== "loaded") {
                    await store.load();
                  }

                  callback && callback(await store.query(params));
                },
                store
              }),
              container: gridDiv
            });

            // create a legend for each layer and add it to the map
            layers.forEach(function(layer, index) {
              const slide = document.createElement("div");
              slide.className = "slide";
              const layerExpression = layer.definitionExpression;

              layer.definitionExpression = `${layerExpression} AND season='${seasons[0]}'`;

              slider.watch("values", function(values) {
                const value = values[0];
                layer.definitionExpression = `${layerExpression} AND season='${seasons[value]}'`;
              });

              const heading = document.createElement("h2");
              heading.className = "heading";
              heading.textContent = layer.title;
              slide.appendChild(heading);

              const legendDiv = document.createElement("div");
              legendDiv.className = "legend";
              const legend = new Legend({
                container: legendDiv,
                view: view,
                layerInfos: [
                  {
                    layer: layer
                  }
                ]
              });
              slide.appendChild(legendDiv);

              content.appendChild(slide);
            });

            return view.when();
          })
          .then(function() {
            let height = 0;

            function updateSize() {
              height = view.height * swipes.length;
              setScroll(scroller.scrollTop);
              content.style.height = height + "px";
            }

            function clamp(value, min, max) {
              return Math.min(max, Math.max(min, value));
            }

            let scroll = 0;
            let ticking = false;
            function setScroll(value) {
              scroll = value;

              if (!ticking) {
                requestAnimationFrame(function() {
                  ticking = false;

                  let pageRatio = scroll / view.height;

                  swipes.forEach(function(swipe, index, swipes) {
                    // add each swipe to the view UI
                    view.ui.add(swipe);

                    let position = (index - pageRatio) * 100;

                    // To achieve this infinite scroll effect we need to swap the layers:
                    //   The layer starts at the bottom, the divider goes up
                    //   Then the next layer starts to show up, so we put back the divider at the bottom and swap the layers.
                    if (position < 0 && swipe.trailingLayers.length) {
                      swipe.leadingLayers.addMany(swipe.trailingLayers);
                      swipe.trailingLayers.removeAll();
                    } else if (position >= 0 && swipe.leadingLayers.length) {
                      swipe.trailingLayers.addMany(swipe.leadingLayers);
                      swipe.leadingLayers.removeAll();
                    }

                    if (position < 0) {
                      position += 100;
                    }

                    swipe.position = clamp(position, 0, 100);
                  });
                });

                ticking = true;
              }
            }

            view.watch("height", updateSize);
            updateSize();

            // show layer legends after map has loaded
            const legendDivs = document.getElementsByClassName("legend");
            for (let i = 0; i < legendDivs.length; i++) {
              legendDivs[i].style.visibility = "visible";
            }

            // stop default scroll
            scroller.addEventListener("wheel", function(event) {
              event.stopImmediatePropagation();
            });

            scroller.addEventListener("scroll", function() {
              setScroll(scroller.scrollTop);
            });
          })
          .catch(function(error) {
            console.error(error);
          });
      });
    </script>
  </head>

  <body>
    <div id="viewDiv"></div>
    <div class="scroller">
      <div class="content"></div>
    </div>
  </body>
</html>
